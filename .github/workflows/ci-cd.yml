name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-tk

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test imports
      run: |
        python -c "
        import sys
        sys.path.insert(0, '.')
        try:
            from utils.resource_utils import get_resource_path, is_executable
            from utils.crypto_utils import get_crypto_instance
            from utils.version_utils import get_current_version
            print('✅ All imports successful')
        except Exception as e:
            print(f'❌ Import error: {e}')
            sys.exit(1)
        "

  release:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    outputs:
      released: ${{ steps.release.outputs.released }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.release.outputs.version }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Create release configuration
      run: |
        # Criar package.json
        cat > package.json << 'EOF'
        {
          "name": "unity-package-forge",
          "version": "1.0.0",
          "description": "Unity Package Forge",
          "main": "main.py",
          "repository": {
            "type": "git",
            "url": "git+https://github.com/${{ github.repository }}.git"
          },
          "keywords": ["unity", "package", "generator"],
          "author": "Nathan da Silva Miranda",
          "license": "MIT"
        }
        EOF

        # Criar configuração do semantic-release
        cat > .releaserc.json << 'EOF'
        {
          "branches": ["main"],
          "plugins": [
            "@semantic-release/commit-analyzer",
            "@semantic-release/release-notes-generator",
            ["@semantic-release/changelog", {
              "changelogFile": "CHANGELOG.md"
            }],
            ["@semantic-release/git", {
              "assets": ["CHANGELOG.md", "package.json"],
              "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
            }],
            "@semantic-release/github"
          ]
        }
        EOF

    - name: Install semantic-release
      run: |
        npm install --save-dev semantic-release @semantic-release/github @semantic-release/changelog @semantic-release/git @semantic-release/commit-analyzer @semantic-release/release-notes-generator

    - name: Run semantic-release
      id: release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Executar semantic-release e capturar saída
        npx semantic-release --dry-run=false
        
        # Verificar se uma nova tag foi criada
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        
        if [ -n "$LATEST_TAG" ]; then
          echo "released=true" >> $GITHUB_OUTPUT
          echo "tag_name=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "version=${LATEST_TAG#v}" >> $GITHUB_OUTPUT
          echo "✅ New release created: $LATEST_TAG"
        else
          echo "released=false" >> $GITHUB_OUTPUT
          echo "tag_name=" >> $GITHUB_OUTPUT
          echo "version=1.0.0" >> $GITHUB_OUTPUT
          echo "ℹ️ No new release created"
        fi

  build:
    needs: [test, release]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            name: windows
            ext: .exe
            artifact_name: unity-package-forge-windows.exe
          - os: ubuntu-latest
            name: linux
            ext: ''
            artifact_name: unity-package-forge-linux
          - os: macos-latest
            name: macos
            ext: ''
            artifact_name: unity-package-forge-macos

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install system dependencies (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-tk

    - name: Install system dependencies (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        brew install python-tk

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller pillow
        
        # Verificar se PIL está instalado corretamente
        python -c "import PIL; print('PIL instalado:', PIL.__version__)"
      shell: bash
        
    - name: Verify system dependencies for tkinter (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        echo "Verificando dependências do sistema para tkinter no Ubuntu"
        dpkg -l | grep -i tk
      shell: bash
        
    - name: Verify system dependencies for tkinter (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        echo "Verificando dependências do sistema para tkinter no macOS"
        brew list | grep -i tk
      shell: bash

    - name: Create version info for Windows
      if: matrix.os == 'windows-latest'
      run: |
        $version = "${{ needs.release.outputs.version }}"
        if ([string]::IsNullOrEmpty($version)) { $version = "1.0.0" }
        
        $versionParts = $version.Split('.')
        $major = [int]$versionParts[0]
        $minor = if ($versionParts.Length -gt 1) { [int]$versionParts[1] } else { 0 }
        $patch = if ($versionParts.Length -gt 2) { [int]$versionParts[2] } else { 0 }
        
        @"
        VSVersionInfo(
          ffi=FixedFileInfo(
            filevers=($major, $minor, $patch, 0),
            prodvers=($major, $minor, $patch, 0),
            mask=0x3f,
            flags=0x0,
            OS=0x4,
            fileType=0x1,
            subtype=0x0,
            date=(0, 0)
          ),
          kids=[
            StringFileInfo(
              [
                StringTable(
                  '040904B0',
                  [
                    StringStruct('CompanyName', 'Nathan da Silva Miranda'),
                    StringStruct('FileDescription', 'Unity Package Forge'),
                    StringStruct('FileVersion', '$version'),
                    StringStruct('InternalName', 'unity-package-forge'),
                    StringStruct('LegalCopyright', 'Copyright (c) 2025 Nathan da Silva Miranda'),
                    StringStruct('OriginalFilename', 'unity-package-forge.exe'),
                    StringStruct('ProductName', 'Unity Package Forge'),
                    StringStruct('ProductVersion', '$version')
                  ]
                )
              ]
            ),
            VarFileInfo([VarStruct('Translation', [1033, 1200])])
          ]
        )
        "@ | Out-File -FilePath "version_info.txt" -Encoding UTF8
      shell: powershell

    - name: Prepare config files (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        Copy-Item -Path config.ini.example -Destination config.ini.safe -Force

        if (-not (Test-Path "config.ini")) {
          Copy-Item -Path config.ini.safe -Destination config.ini -Force
          echo "Criado config.ini a partir do exemplo seguro"
        } else {
          echo "config.ini já existe"
        }
      shell: pwsh
      
    - name: Prepare config files (Unix)
      if: matrix.os == 'ubuntu-latest' || matrix.os == 'macos-latest'
      run: |
        cp config.ini.example config.ini.safe

        if [ ! -f "config.ini" ]; then
          cp config.ini.safe config.ini
          echo "Criado config.ini a partir do exemplo seguro"
        else
          echo "config.ini já existe"
        fi
      shell: bash

    - name: Generate spec file and build executable (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        echo "Building Unity Package Forge..."
        echo "Version: ${{ needs.release.outputs.version }}"
        echo "OS: ${{ matrix.os }}"
        
        # Gerar arquivo spec se não existir
        if (-not (Test-Path "unity_package_forge.spec")) {
          echo "⚠️ Spec file not found, generating..."
          python -c "
          import os
          import platform
          
          # Determinar configurações específicas da plataforma
          is_windows = platform.system() == 'Windows'
          icon_path = os.path.join('ui', 'icon.ico')
          icon_line = f\"icon='{icon_path}'\" if os.path.exists(icon_path) else \"icon=None\"
          version_line = \"version='version_info.txt'\" if is_windows else \"version=None\"
          
          # Criar conteúdo do spec
          spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
          
          block_cipher = None
          
          a = Analysis(
              ['main.py'],
              pathex=[],
              binaries=[],
              datas=[],
              hiddenimports=[
                  'customtkinter',
                  'requests',
                  'cryptography',
                  'cryptography.fernet',
                  'cryptography.hazmat.primitives',
                  'cryptography.hazmat.primitives.kdf.pbkdf2',
                  'threading',
                  'queue',
                  'tkinter',
                  'tkinter.ttk',
                  'tkinter.messagebox',
                  'tkinter.filedialog',
                  'json',
                  'configparser',
                  'pathlib',
                  'subprocess',
                  'shutil',
                  'zipfile',
                  'tempfile',
                  'datetime',
                  'hashlib',
                  'base64',
                  'webbrowser',
                  'platform',
                  'getpass',
                  'ui.ctk_generator_gui',
                  'ui.strings',
                  'utils.resource_utils',
                  'utils.crypto_utils',
                  'utils.version_utils',
                  'utils.helpers',
                  'core.package_generator',
                  'core.github_manager',
                  'config.config_manager',
                  'PIL._tkinter_finder',
              ],
              hookspath=[],
              hooksconfig={{}},
              runtime_hooks=[],
              excludes=[
                  'matplotlib',
                  'numpy',
                  'pandas',
                  'scipy',
                  'jupyter',
                  'notebook',
                  'IPython',
                  'tornado',
                  'zmq',
                  'pygame',
                  'cv2',
                  'PyQt5',
                  'PyQt6',
                  'PySide2',
                  'PySide6',
                  'wx',
                  'tkinter.test',
                  'test',
                  'tests',
                  'unittest',
                  'doctest',
                  'pydoc',
              ],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='unity-package-forge',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=False,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              {version_line},
              {icon_line},
          )'''
          
          # Escrever arquivo spec
          with open('unity_package_forge.spec', 'w', encoding='utf-8') as f:
              f.write(spec_content)
          
          print('✅ Arquivo unity_package_forge.spec criado com sucesso!')
          "
        }
        
        # Construir o executável com opções para resolver problemas de importação
        pyinstaller unity_package_forge.spec --clean --noconfirm --log-level INFO --hidden-import PIL._tkinter_finder
        
        # Verificar resultado da build
        echo "Verificando resultado da build:"
        if (Test-Path "dist") {
          Get-ChildItem -Path dist -Recurse -File | Sort-Object FullName
        } else {
          echo "Diretório dist não foi criado!"
        }
      shell: pwsh
      
    - name: Generate spec file and build executable (Unix)
      if: matrix.os == 'ubuntu-latest' || matrix.os == 'macos-latest'
      run: |
        echo "Building Unity Package Forge..."
        echo "Version: ${{ needs.release.outputs.version }}"
        echo "OS: ${{ matrix.os }}"
        
        # Gerar arquivo spec se não existir
        if [ ! -f "unity_package_forge.spec" ]; then
          echo "⚠️ Spec file not found, generating..."
          python -c "
          import os
          import platform
          
          # Determinar configurações específicas da plataforma
          is_windows = platform.system() == 'Windows'
          icon_path = os.path.join('ui', 'icon.ico')
          icon_line = f\"icon='{icon_path}'\" if os.path.exists(icon_path) else \"icon=None\"
          version_line = \"version='version_info.txt'\" if is_windows else \"version=None\"
          
          # Criar conteúdo do spec
          spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
          
          block_cipher = None
          
          a = Analysis(
              ['main.py'],
              pathex=[],
              binaries=[],
              datas=[],
              hiddenimports=[
                  'customtkinter',
                  'requests',
                  'cryptography',
                  'cryptography.fernet',
                  'cryptography.hazmat.primitives',
                  'cryptography.hazmat.primitives.kdf.pbkdf2',
                  'threading',
                  'queue',
                  'tkinter',
                  'tkinter.ttk',
                  'tkinter.messagebox',
                  'tkinter.filedialog',
                  'json',
                  'configparser',
                  'pathlib',
                  'subprocess',
                  'shutil',
                  'zipfile',
                  'tempfile',
                  'datetime',
                  'hashlib',
                  'base64',
                  'webbrowser',
                  'platform',
                  'getpass',
                  'ui.ctk_generator_gui',
                  'ui.strings',
                  'utils.resource_utils',
                  'utils.crypto_utils',
                  'utils.version_utils',
                  'utils.helpers',
                  'core.package_generator',
                  'core.github_manager',
                  'config.config_manager',
              ],
              hookspath=[],
              hooksconfig={{}},
              runtime_hooks=[],
              excludes=[
                  'matplotlib',
                  'numpy',
                  'pandas',
                  'scipy',
                  'jupyter',
                  'notebook',
                  'IPython',
                  'tornado',
                  'zmq',
                  'pygame',
                  'cv2',
                  'PyQt5',
                  'PyQt6',
                  'PySide2',
                  'PySide6',
                  'wx',
                  'tkinter.test',
                  'test',
                  'tests',
                  'unittest',
                  'doctest',
                  'pydoc',
                  '_tkinter',
              ],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='unity-package-forge',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=False,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              {version_line},
              {icon_line},
          )'''
          
          # Escrever arquivo spec
          with open('unity_package_forge.spec', 'w', encoding='utf-8') as f:
              f.write(spec_content)
          
          print('✅ Arquivo unity_package_forge.spec criado com sucesso!')
          "
        fi
        
        # Construir o executável com opções para resolver problemas de importação
        pyinstaller unity_package_forge.spec --clean --noconfirm --log-level INFO --exclude-module _tkinter
        
        # Verificar resultado da build
        echo "Verificando resultado da build:"
        if [ -d "dist" ]; then
          find dist -type f | sort
        else
          echo "Diretório dist não foi criado!"
        fi
      shell: bash

    - name: Verify and prepare build (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        echo "=== Verificando saída da build ==="
        
        if (-not (Test-Path "dist")) {
          echo "❌ Diretório dist não encontrado!"
          exit 1
        }
        
        echo "Conteúdo do diretório dist:"
        Get-ChildItem -Path dist -Recurse
        
        # Localizar o executável - verificar tanto na raiz quanto em subdiretórios
        $EXEC_NAME = "unity-package-forge.exe"
        
        # Procurar o executável em dist e seus subdiretórios
        $EXEC_PATH = Get-ChildItem -Path dist -Recurse -Filter $EXEC_NAME | Select-Object -First 1 -ExpandProperty FullName
        
        if ($EXEC_PATH -and (Test-Path $EXEC_PATH -PathType Leaf)) {
          echo "✅ Executável encontrado: $EXEC_PATH"
          
          # Verificar tamanho
          $SIZE = (Get-Item $EXEC_PATH).Length / 1MB
          echo "Tamanho: $([math]::Round($SIZE, 2)) MB"
          
          # Criar diretório dist se não existir (por precaução)
          if (-not (Test-Path "dist")) {
            New-Item -Path "dist" -ItemType Directory
          }
          
          # Copiar para o nome final
          Copy-Item -Path $EXEC_PATH -Destination "dist/${{ matrix.artifact_name }}" -Force
          echo "✅ Copiado para: dist/${{ matrix.artifact_name }}"
        } else {
          echo "❌ Executável não encontrado!"
          echo "Procurando por arquivos na pasta dist:"
          Get-ChildItem -Path dist -Recurse -File | Sort-Object FullName
          exit 1
        }
      shell: pwsh
      
    - name: Verify and prepare build (Unix)
      if: matrix.os == 'ubuntu-latest' || matrix.os == 'macos-latest'
      run: |
        echo "=== Verificando saída da build ==="
        
        if [ ! -d "dist" ]; then
          echo "❌ Diretório dist não encontrado!"
          exit 1
        fi
        
        echo "Conteúdo do diretório dist:"
        ls -la dist/
        
        # Localizar o executável - verificar tanto na raiz quanto em subdiretórios
        EXEC_NAME="unity-package-forge"
        
        # Procurar o executável em dist e seus subdiretórios
        EXEC_PATH=$(find dist -name "$EXEC_NAME" -type f | head -n 1)
        
        if [ -n "$EXEC_PATH" ] && [ -f "$EXEC_PATH" ]; then
          echo "✅ Executável encontrado: $EXEC_PATH"
          
          # Verificar tamanho
          SIZE=$(du -h "$EXEC_PATH" | cut -f1)
          echo "Tamanho: $SIZE"
          
          # Criar diretório dist se não existir (por precaução)
          mkdir -p dist
          
          # Copiar para o nome final (em vez de mover, para evitar problemas de permissão)
          cp "$EXEC_PATH" "dist/${{ matrix.artifact_name }}"
          echo "✅ Copiado para: dist/${{ matrix.artifact_name }}"
          
          # Tornar executável no Linux/macOS
          chmod +x "dist/${{ matrix.artifact_name }}"
          echo "✅ Permissões de execução definidas"
        else
          echo "❌ Executável não encontrado!"
          echo "Procurando por arquivos na pasta dist:"
          find dist -type f | sort
          exit 1
        fi
      shell: bash

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: dist/${{ matrix.artifact_name }}
        retention-days: 30

    - name: Upload to GitHub Release
      if: needs.release.outputs.released == 'true'
      uses: softprops/action-gh-release@v2
      with:
        files: dist/${{ matrix.artifact_name }}
        tag_name: ${{ needs.release.outputs.tag_name }}
        name: Release ${{ needs.release.outputs.tag_name }}
        body: |
          ## 🚀 Unity Package Forge ${{ needs.release.outputs.tag_name }}

          ### Download executáveis:

          - 🪟 **Windows**: [unity-package-forge-windows.exe](https://github.com/${{ github.repository }}/releases/download/${{ needs.release.outputs.tag_name }}/unity-package-forge-windows.exe)
          - 🐧 **Linux**: [unity-package-forge-linux](https://github.com/${{ github.repository }}/releases/download/${{ needs.release.outputs.tag_name }}/unity-package-forge-linux)  
          - 🍎 **macOS**: [unity-package-forge-macos](https://github.com/${{ github.repository }}/releases/download/${{ needs.release.outputs.tag_name }}/unity-package-forge-macos)

          ### Instalação:

          **Windows**: Baixe o `.exe` e execute. Se o Windows Defender bloquear, clique em "Mais informações" → "Executar mesmo assim".

          **Linux**: 
          ```bash
          chmod +x unity-package-forge-linux
          ./unity-package-forge-linux
          ```

          **macOS**: 
          ```bash
          chmod +x unity-package-forge-macos
          ./unity-package-forge-macos
          ```

        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}